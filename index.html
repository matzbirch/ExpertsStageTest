<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ExpertsStage</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .popup-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            max-width: 700px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 1000;
        }
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }
        .popup-card h3 {
            margin: 0;
            color: #333;
            font-size: 18px;
            font-weight: 600;
        }
        .popup-content {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        .author-image {
            width: 300px;
            height: 300px;
            object-fit: cover;
            border-radius: 10px;
            flex-shrink: 0;
        }
        .content-text {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .content-title {
            font-size: 20px;
            font-weight: 700;
            color: #333;
            margin: 0;
        }
        .content-subtext {
            color: #666;
            line-height: 1.6;
            margin: 0;
            font-size: 14px;
        }
        .view-report-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 15px;
            transition: all 0.3s ease;
        }
        .view-report-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 0;
            line-height: 1;
        }
        .close-btn:hover {
            color: #333;
        }
        /* Stats.js will be added dynamically */
    </style>
</head>
<body>
    <div class="popup-card" id="popup-card">
        <div class="popup-header">
            <h3 id="popup-title">Author Name</h3>
            <button class="close-btn" onclick="closePopup()">&times;</button>
        </div>
        <div class="popup-content">
            <img id="popup-image" class="author-image" src="" alt="Report Image">
            <div class="content-text">
                <h4 id="content-title" class="content-title">Expert Title</h4>
                <p id="content-subtext" class="content-subtext">Expert information will appear here.</p>
            </div>
        </div>
        <button class="view-report-btn" id="view-report-btn" onclick="openReport()">View Report</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://unpkg.com/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="module">
        // Import Three.js using import map
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
        // Stats.js is loaded via script tag
        
        console.log("Script started");
        
        let scene, camera, renderer, controls;
        let authorObjects = [];
        let categoriesObjects = [];
        let authorTextObjects = [];
        let categoriesTitleObjects = [];
        let raycaster, mouse;
        let composer;
        let authorTextures = {};
        let authorTextTextures = {};
        let categoryTitleTextures = {};
        let currentAuthorNumber = null;
        let textAndLinksConfig = null;
        let texturesLoaded = 0;
        let modelLoaded = false;
        let hoveredCategory = null;
        let categoryGroups = {}; // Store grouped objects for each category
        let lockedCategory = null; // Store which category is locked facing camera
        let originalCameraTarget = null; // Store original camera target for reset
        let originalCameraPosition = null; // Store original camera position for zoom reset
        let cameraAnimationComplete = false; // Track if initial camera animation is done
        let mouseFollowEnabled = false; // Track if mouse following is enabled
        let mousePosition = { x: 0, y: 0 }; // Normalized mouse position (-1 to 1)
        let targetCameraPosition = null; // Target position for smooth mouse following
        let cameraTransitioning = false; // Track if camera is in transition to prevent conflicts
        
        // Mobile device detection and touch controls
        let isMobile = false;
        let touchEnabled = false;
        let touchStartPosition = { x: 0, y: 0 };
        let touchCurrentPosition = { x: 0, y: 0 };
        let touchDelta = { x: 0, y: 0 };
        let isTouching = false;
        let stageLight = null; // Store the stage-based light
        
        // Initialize Stats.js for FPS monitoring
        const stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild(stats.dom);
        
        // Performance monitoring variables
        let performanceStats = {
            fps: 0,
            frameTime: 0,
            lastTime: performance.now(),
            frameCount: 0,
            fpsUpdateInterval: 60, // Update FPS every 60 frames
            startTime: performance.now(),
            modelLoadStart: 0,
            modelLoadEnd: 0,
            textureLoadStart: 0,
            textureLoadEnd: 0,
            configLoadStart: 0,
            configLoadEnd: 0,
            triangleCount: 0
        };

        // Create text texture for opacity mapping
        function createTextTexture(text, fontSize = 64, fontFamily = 'Arial', textColor = '#ffffff', backgroundColor = '#000000') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Use fixed canvas size for all category titles to ensure uniform scaling and alignment
            const canvasWidth = 600;  // Fixed width for all category titles
            const canvasHeight = 600; // Fixed height for all category titles
            
            // Set canvas size as fixed square
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // Enable high-quality text rendering
            context.textRenderingOptimization = 'optimizeQuality';
            context.imageSmoothingEnabled = true;
            context.imageSmoothingQuality = 'high';
            
            // Set background
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set text properties with fixed font size for consistency
            context.fillStyle = textColor;
            context.font = `bold ${fontSize}px ${fontFamily}`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Add text shadow for better visibility and crispness
            context.shadowColor = 'rgba(0, 0, 0, 0.8)';
            context.shadowBlur = 2;
            context.shadowOffsetX = 1;
            context.shadowOffsetY = 1;
            
            // Draw text centered in the square canvas
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // Create texture with proper settings for crisp text
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.flipY = false;
            texture.generateMipmaps = false; // Disable mipmaps for crisp text
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            // Set proper color space for text textures
            texture.colorSpace = THREE.SRGBColorSpace;
            
            return texture;
        }
        
        // Create multi-line text texture for opacity mapping
        function createMultiLineTextTexture(text, baseFontSize = 64, fontFamily = 'Arial', textColor = '#ffffff', backgroundColor = '#000000') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Split text into lines
            const lines = text.split('\n');
            
            // Fixed font sizes for absolute consistency across all cards
            const nameFontSize = 56;      // Fixed size for names
            const titleFontSize = 46;     // Fixed size for author titles  
            const reportFontSize = 36;    // Fixed size for report titles
            const lineHeight = 68;        // Fixed line height for consistency
            
            // Function to wrap text if it's too long
            function wrapText(text, fontSize, maxWidth) {
                context.font = `normal ${fontSize}px ${fontFamily}`;
                const words = text.split(' ');
                const wrappedLines = [];
                let currentLine = '';
                
                for (let word of words) {
                    const testLine = currentLine + (currentLine ? ' ' : '') + word;
                    const metrics = context.measureText(testLine);
                    
                    if (metrics.width > maxWidth && currentLine) {
                        wrappedLines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                
                if (currentLine) {
                    wrappedLines.push(currentLine);
                }
                
                return wrappedLines;
            }
            
            // Process each line and handle wrapping for report titles
            let maxWidth = 0;
            const lineMetrics = [];
            const maxReportTitleWidth = 600; // Maximum width before wrapping
            
            lines.forEach((line, index) => {
                let currentFontSize, fontWeight;
                let processedLines = [line]; // Default to single line
                
                if (index === 0) {
                    // Name - fixed size, bold
                    currentFontSize = nameFontSize;
                    fontWeight = 'bold';
                } else if (index === 1) {
                    // Author Title - fixed size, normal
                    currentFontSize = titleFontSize;
                    fontWeight = 'normal';
                } else {
                    // Report Title - fixed size, normal, with wrapping
                    currentFontSize = reportFontSize;
                    fontWeight = 'normal';
                    processedLines = wrapText(line, currentFontSize, maxReportTitleWidth);
                }
                
                // Process each line (wrapped or single)
                processedLines.forEach(processedLine => {
                    context.font = `${fontWeight} ${currentFontSize}px ${fontFamily}`;
                    const metrics = context.measureText(processedLine);
                    const lineWidth = metrics.width;
                    maxWidth = Math.max(maxWidth, lineWidth);
                    
                    lineMetrics.push({
                        text: processedLine,
                        width: lineWidth,
                        fontSize: currentFontSize,
                        fontWeight: fontWeight
                    });
                });
            });
            
            // Calculate canvas size - use fixed size for absolute consistency
            const padding = 0; // Reduced padding since we're going to far left
            const totalHeight = lineMetrics.length * lineHeight;
            
            // Use fixed canvas size for all cards to ensure uniform scaling and alignment
            const canvasWidth = 600;  // Fixed width for all cards
            const canvasHeight = 600; // Fixed height for all cards
            
            // Set canvas size as fixed rectangle
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // Enable high-quality text rendering
            context.textRenderingOptimization = 'optimizeQuality';
            context.imageSmoothingEnabled = true;
            context.imageSmoothingQuality = 'high';
            
            // Set background
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw each line with far-left alignment and static author name positioning
            const authorNameY = 160;  // Fixed Y position for author name across all cards
            const leftMargin = 0;   // Minimal left margin - almost at edge
            
            lineMetrics.forEach((lineData, index) => {
                let y;
                
                if (index === 0) {
                    // Author name - fixed position for horizontal alignment across all cards
                    y = authorNameY;
                } else {
                    // Other lines - positioned relative to author name
                    y = authorNameY + (index * lineHeight);
                }
                
                // Set font for this line with exact sizing
                context.font = `${lineData.fontWeight} ${lineData.fontSize}px ${fontFamily}`;
                context.fillStyle = textColor;
                context.textAlign = 'left';
                context.textBaseline = 'middle';
                
                // Add text shadow for better visibility
                context.shadowColor = 'rgba(0, 0, 0, 0.8)';
                context.shadowBlur = 2;
                context.shadowOffsetX = 1;
                context.shadowOffsetY = 1;
                
                // Draw the line at far left with minimal margin
                context.fillText(lineData.text, leftMargin, y);
            });
            
            // Create texture with proper settings for crisp text
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.flipY = false;
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            // Set proper color space for multi-line text textures
            texture.colorSpace = THREE.SRGBColorSpace;
            
            return texture;
        }
        
        // Generate text textures for authors
        function generateAuthorTextTextures() {
            if (!textAndLinksConfig || !textAndLinksConfig.authors) {
                console.warn('Text and links config not loaded, using fallback author names');
                // Fallback author names with three-line format
                for (let i = 1; i <= 8; i++) {
                    const text = `Author ${i}\nSenior Expert\nTechnology Implementation Report`;
                    authorTextTextures[i] = createMultiLineTextTexture(text, 64, 'Arial', '#ffffff', '#000000');
                }
                return;
            }
            
            // Generate textures from config with three-line format
            Object.keys(textAndLinksConfig.authors).forEach(authorNum => {
                const authorData = textAndLinksConfig.authors[authorNum];
                const name = authorData.name || `Author ${authorNum}`;
                const authorTitle = authorData.authorTitle || 'Senior Expert';
                const reportTitle = authorData.reportTitle || 'Technology Implementation Report';
                const text = `${name}\n${authorTitle}\n${reportTitle}`;
                authorTextTextures[authorNum] = createMultiLineTextTexture(text, 64, 'Arial', '#ffffff', '#000000');
                console.log(`Generated text texture for: ${name} - ${authorTitle} - ${reportTitle}`);
            });
        }
        
        // Generate text textures for categories
        function generateCategoryTitleTextures() {
            // Fixed font size for consistent category title sizing across all objects
            const categoryTitleFontSize = 48;
            
            if (!textAndLinksConfig || !textAndLinksConfig.categories) {
                console.warn('Category config not found, using fallback category titles');
                // Fallback category titles
                const fallbackTitles = [
                    'Technology Innovation',
                    'Research & Development', 
                    'Strategic Solutions',
                    'Industry Leadership'
                ];
                
                for (let i = 1; i <= 4; i++) {
                    const text = fallbackTitles[i - 1] || `Category ${i}`;
                    categoryTitleTextures[i] = createTextTexture(text, categoryTitleFontSize, 'Arial', '#ffffff', '#000000');
                }
                return;
            }
            
            // Generate textures from config with consistent font size
            Object.keys(textAndLinksConfig.categories).forEach(categoryNum => {
                const categoryData = textAndLinksConfig.categories[categoryNum];
                const text = categoryData.title || `Category ${categoryNum}`;
                categoryTitleTextures[categoryNum] = createTextTexture(text, categoryTitleFontSize, 'Arial', '#ffffff', '#000000');
                console.log(`Generated category title texture for: ${text}`);
            });
        }
        
        // Utility function to manually update matrices for objects
        function updateObjectMatrices(object) {
            if (object.matrixAutoUpdate === false) {
                object.updateMatrix();
            }
            // Also update children if they exist
            if (object.children && object.children.length > 0) {
                object.children.forEach(child => updateObjectMatrices(child));
            }
        }
        
        // Camera mouse following function
        function updateCameraFollowMouse() {
            if (!originalCameraPosition || !originalCameraTarget) return;
            
            // Calculate enhanced camera movement based on mouse position
            const followStrength = 1.8; // How much the camera follows the mouse (0-1) - increased from 1.0
            const followRange = 15; // Maximum distance the camera can move from original position - increased from 6
            
            // Movement range limits to prevent camera from going too far (desktop limits)
            const maxMovementX = 22; // Maximum X movement from original position
            const maxMovementY = 6;  // Maximum Y movement from original position
            const maxMovementZ = 5;  // Maximum Z movement from original position
            
            // Calculate offset from mouse position
            const offsetX = mousePosition.x * followRange * followStrength;
            const offsetY = mousePosition.y * followRange * followStrength * 0.5; // Reduce vertical movement
            
            // Calculate target position
            if (!targetCameraPosition) {
                targetCameraPosition = originalCameraPosition.clone();
            }
            
            const newTargetPosition = originalCameraPosition.clone();
            newTargetPosition.x += offsetX;
            newTargetPosition.y += offsetY;
            
            // Apply movement range limits
            const deltaX = newTargetPosition.x - originalCameraPosition.x;
            const deltaY = newTargetPosition.y - originalCameraPosition.y;
            const deltaZ = newTargetPosition.z - originalCameraPosition.z;
            
            // Clamp the deltas to the maximum movement ranges
            const clampedDeltaX = Math.max(-maxMovementX, Math.min(maxMovementX, deltaX));
            const clampedDeltaY = Math.max(-maxMovementY, Math.min(maxMovementY, deltaY));
            const clampedDeltaZ = Math.max(-maxMovementZ, Math.min(maxMovementZ, deltaZ));
            
            // Apply clamped position
            newTargetPosition.x = originalCameraPosition.x + clampedDeltaX;
            newTargetPosition.y = originalCameraPosition.y + clampedDeltaY;
            newTargetPosition.z = originalCameraPosition.z + clampedDeltaZ;
            
            // Smooth interpolation to target position
            const lerpFactor = 0.06; // How smooth the movement is (lower = smoother) - increased from 0.03 for faster response
            targetCameraPosition.lerp(newTargetPosition, lerpFactor);
            
            // Apply the position
            camera.position.copy(targetCameraPosition);
            
            // Optionally adjust the target slightly as well for more dynamic feel
            const targetOffset = originalCameraTarget.clone();
            targetOffset.x += clampedDeltaX * 0.4; // Use clamped values for target offset too
            targetOffset.y += clampedDeltaY * 0.4;
            
            controls.target.lerp(targetOffset, lerpFactor);
        }
        
        // Smooth transition back to mouse following
        function smoothTransitionToMouseFollow() {
            // Mark as transitioning to prevent conflicts
            cameraTransitioning = true;
            mouseFollowEnabled = false;
            
            // Calculate where the camera should be based on current mouse position
            const followStrength = 1.8;
            const followRange = 15;
            const offsetX = mousePosition.x * followRange * followStrength;
            const offsetY = mousePosition.y * followRange * followStrength * 0.5;
            
            // Movement range limits (same as in updateCameraFollowMouse)
            const maxMovementX = 12;
            const maxMovementY = 8;
            const maxMovementZ = 5;
            
            const targetMousePosition = originalCameraPosition.clone();
            targetMousePosition.x += offsetX;
            targetMousePosition.y += offsetY;
            
            // Apply movement range limits
            const deltaX = targetMousePosition.x - originalCameraPosition.x;
            const deltaY = targetMousePosition.y - originalCameraPosition.y;
            const deltaZ = targetMousePosition.z - originalCameraPosition.z;
            
            // Clamp the deltas to the maximum movement ranges
            const clampedDeltaX = Math.max(-maxMovementX, Math.min(maxMovementX, deltaX));
            const clampedDeltaY = Math.max(-maxMovementY, Math.min(maxMovementY, deltaY));
            const clampedDeltaZ = Math.max(-maxMovementZ, Math.min(maxMovementZ, deltaZ));
            
            // Apply clamped position
            targetMousePosition.x = originalCameraPosition.x + clampedDeltaX;
            targetMousePosition.y = originalCameraPosition.y + clampedDeltaY;
            targetMousePosition.z = originalCameraPosition.z + clampedDeltaZ;
            
            const targetMouseTarget = originalCameraTarget.clone();
            targetMouseTarget.x += clampedDeltaX * 0.4;
            targetMouseTarget.y += clampedDeltaY * 0.4;
            
            // Store current positions
            const currentPosition = camera.position.clone();
            const currentTarget = controls.target.clone();
            
            // Animate to mouse-following position
            const duration = 600; // Reduced to 0.6 second for snappier feel
            const startTime = Date.now();
            
            function animateToMouseFollow() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing
                const easeOut = 1 - Math.pow(1 - progress, 3);
                
                // Interpolate to mouse-following position
                camera.position.lerpVectors(currentPosition, targetMousePosition, easeOut);
                controls.target.lerpVectors(currentTarget, targetMouseTarget, easeOut);
                
                // Update target camera position for smooth continuation
                if (!targetCameraPosition) {
                    targetCameraPosition = originalCameraPosition.clone();
                }
                targetCameraPosition.lerpVectors(currentPosition, targetMousePosition, easeOut);
                
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animateToMouseFollow);
            } else {
                    // Transition complete - enable mouse following
                    cameraTransitioning = false;
                    mouseFollowEnabled = true;
                    console.log("Smooth transition to mouse following complete");
                }
            }
            
            animateToMouseFollow();
        }
        
        // Simple camera reset to default without tilt animation
        function resetCameraToDefault() {
            if (!originalCameraTarget || !originalCameraPosition) return;
            
            // Disable mouse following and mark as transitioning
            mouseFollowEnabled = false;
            cameraTransitioning = true;
            
            // Store current target and position
            const currentTarget = controls.target.clone();
            const currentPosition = camera.position.clone();
            
            // Animate camera directly back to original position
            const duration = 800; // Faster than full reset
            const startTime = Date.now();
            
            function animateDirectReset() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing
                const easeOut = 1 - Math.pow(1 - progress, 3);
                
                // Interpolate directly to original position
                controls.target.lerpVectors(currentTarget, originalCameraTarget, easeOut);
                camera.position.lerpVectors(currentPosition, originalCameraPosition, easeOut);
                
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animateDirectReset);
                } else {
                    // Reset complete - prepare for smooth transition to mouse following
                    targetCameraPosition = originalCameraPosition.clone();
                    cameraTransitioning = false;
                    
                    // Start smooth transition to mouse following after a brief delay
                    setTimeout(() => {
                        if (cameraAnimationComplete && !lockedCategory) {
                            // Ensure camera is exactly at original position before transitioning
                            camera.position.copy(originalCameraPosition);
                            controls.target.copy(originalCameraTarget);
                            controls.update();
                            
                            smoothTransitionToMouseFollow();
                        }
                    }, 100);
                    
                    console.log("Camera reset to default position, preparing for mouse following");
                }
            }
            
            animateDirectReset();
        }
        
        // Performance monitoring functions
        function updatePerformanceStats() {
            const currentTime = performance.now();
            const deltaTime = currentTime - performanceStats.lastTime;
            performanceStats.frameTime = deltaTime;
            performanceStats.frameCount++;
            
            // Update FPS every N frames for smoother display
            if (performanceStats.frameCount % performanceStats.fpsUpdateInterval === 0) {
                performanceStats.fps = Math.round(1000 / deltaTime);
                updateStatsDisplay();
            }
            
            performanceStats.lastTime = currentTime;
        }
        
        function updateStatsDisplay() {
            // FPS with color coding
            const fpsElement = document.getElementById('fps-value');
            const fps = performanceStats.fps;
            fpsElement.textContent = fps;
            fpsElement.className = 'stats-value';
            if (fps < 30) fpsElement.className += ' error';
            else if (fps < 50) fpsElement.className += ' warning';
            
            // Frame time
            const frameTimeElement = document.getElementById('frame-time-value');
            frameTimeElement.textContent = `${performanceStats.frameTime.toFixed(1)}ms`;
            frameTimeElement.className = 'stats-value';
            if (performanceStats.frameTime > 33) frameTimeElement.className += ' error';
            else if (performanceStats.frameTime > 20) frameTimeElement.className += ' warning';
            
            // Load times
            if (performanceStats.modelLoadEnd > 0) {
                const modelLoadTime = performanceStats.modelLoadEnd - performanceStats.modelLoadStart;
                document.getElementById('model-load-time').textContent = `${modelLoadTime.toFixed(0)}ms`;
            }
            
            if (performanceStats.textureLoadEnd > 0) {
                const textureLoadTime = performanceStats.textureLoadEnd - performanceStats.textureLoadStart;
                document.getElementById('texture-load-time').textContent = `${textureLoadTime.toFixed(0)}ms`;
            }
            
            if (performanceStats.configLoadEnd > 0) {
                const configLoadTime = performanceStats.configLoadEnd - performanceStats.configLoadStart;
                document.getElementById('config-load-time').textContent = `${configLoadTime.toFixed(0)}ms`;
            }
            
            // Total load time
            const totalLoadTime = performance.now() - performanceStats.startTime;
            document.getElementById('total-load-time').textContent = `${totalLoadTime.toFixed(0)}ms`;
            
            // Memory usage (if available)
            if (performance.memory) {
                const memoryMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                document.getElementById('memory-usage').textContent = `${memoryMB}MB`;
            } else {
                document.getElementById('memory-usage').textContent = 'N/A';
            }
            
            // Triangle count
            if (performanceStats.triangleCount > 0) {
                const triangles = performanceStats.triangleCount.toLocaleString();
                document.getElementById('triangle-count').textContent = triangles;
            }
        }
        
        function countTriangles(object) {
            let triangleCount = 0;
            object.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const geometry = child.geometry;
                    if (geometry.index) {
                        triangleCount += geometry.index.count / 3;
                    } else if (geometry.attributes.position) {
                        triangleCount += geometry.attributes.position.count / 3;
                    }
                }
            });
            return Math.floor(triangleCount);
        }
        
        // Popup functions
        window.closePopup = function() {
            document.getElementById('popup-card').style.display = 'none';
            
            // Re-enable camera controls and smoothly transition to mouse following (if no category is locked)
            controls.enabled = true;
            if (cameraAnimationComplete && !lockedCategory) {
                smoothTransitionToMouseFollow();
            }
        }
        
        window.openReport = function() {
            if (currentAuthorNumber && textAndLinksConfig?.authors?.[currentAuthorNumber]?.link) {
                window.open(textAndLinksConfig.authors[currentAuthorNumber].link, '_blank');
            } else {
                alert('Report link not available yet.');
            }
        }
        

        
        // Load text and links configuration
        async function loadTextAndLinksConfig() {
            performanceStats.configLoadStart = performance.now();
            try {
                const response = await fetch('text-and-links.json');
                textAndLinksConfig = await response.json();
                performanceStats.configLoadEnd = performance.now();
                console.log('Text and links configuration loaded successfully');
            } catch (error) {
                performanceStats.configLoadEnd = performance.now();
                console.error('Error loading text and links configuration:', error);
                // Fallback configuration
                textAndLinksConfig = {
                    authors: {
                        "1": { name: "Dr. Sarah Chen", authorTitle: "Senior Cloud Architect", reportTitle: "Cloud Infrastructure for AI: A Strategic Guide", subtext: "Expert information", link: "https://get.itexpertresource.com/aws/the-public-sector-journey-to-generative-ai-a-cios-guide-to-strategic-implementation/" },
                        "2": { name: "Marcus Rodriguez", authorTitle: "Principal Data Scientist", reportTitle: "Generative AI Applications in Enterprise", subtext: "Expert information", link: "https://get.itexpertresource.com/aws/the-public-sector-journey-to-generative-ai-a-cios-guide-to-strategic-implementation/" },
                        "3": { name: "Dr. Aisha Patel", authorTitle: "Chief Technology Officer", reportTitle: "Digital Transformation Roadmap 2024", subtext: "Expert information", link: "https://get.itexpertresource.com/aws/the-public-sector-journey-to-generative-ai-a-cios-guide-to-strategic-implementation/" },
                        "4": { name: "James Thompson", authorTitle: "Solutions Architect", reportTitle: "Public Sector AI Implementation Framework", subtext: "Expert information", link: "https://get.itexpertresource.com/aws/the-public-sector-journey-to-generative-ai-a-cios-guide-to-strategic-implementation/" },
                        "5": { name: "Dr. Elena Kowalski", authorTitle: "Research Director", reportTitle: "Machine Learning Innovation Trends Report", subtext: "Expert information", link: "https://get.itexpertresource.com/aws/the-public-sector-journey-to-generative-ai-a-cios-guide-to-strategic-implementation/" },
                        "6": { name: "David Kim", authorTitle: "Enterprise Architect", reportTitle: "Secure Cloud Architecture Best Practices", subtext: "Expert information", link: "https://get.itexpertresource.com/aws/the-public-sector-journey-to-generative-ai-a-cios-guide-to-strategic-implementation/" },
                        "7": { name: "Dr. Rachel Foster", authorTitle: "AI Ethics Researcher", reportTitle: "Responsible AI Development Guidelines", subtext: "Expert information", link: "https://get.itexpertresource.com/aws/the-public-sector-journey-to-generative-ai-a-cios-guide-to-strategic-implementation/" },
                        "8": { name: "Michael Zhang", authorTitle: "Technical Program Manager", reportTitle: "AI Implementation Strategy Playbook", subtext: "Expert information", link: "https://get.itexpertresource.com/aws/the-public-sector-journey-to-generative-ai-a-cios-guide-to-strategic-implementation/" }
                    },
                    categories: {
                        "1": { title: "Technology Innovation" },
                        "2": { title: "Research & Development" },
                        "3": { title: "Strategic Solutions" },
                        "4": { title: "Industry Leadership" }
                    }
                };
            }
            
            // Generate text textures after config is loaded
            generateAuthorTextTextures();
            generateCategoryTitleTextures();
        }

        function showPopup(authorName, authorObject) {
            const popup = document.getElementById('popup-card');
            const title = document.getElementById('popup-title');
            const contentTitle = document.getElementById('content-title');
            const contentSubtext = document.getElementById('content-subtext');
            const image = document.getElementById('popup-image');
            
            // Extract author number from name (e.g., "Author1" -> "1")
            const authorNumber = authorName.replace(/\D/g, '');
            currentAuthorNumber = authorNumber;
            
            // Get configuration for this author
            const authorConfig = textAndLinksConfig?.authors?.[authorNumber];
            
            if (authorConfig) {
                title.textContent = authorConfig.name;
                contentTitle.textContent = authorConfig.authorTitle;
                contentSubtext.textContent = authorConfig.subtext;
            } else {
                // Fallback content
                title.textContent = authorName;
                contentTitle.textContent = `Senior Expert ${authorNumber}`;
                contentSubtext.textContent = `Information about ${authorName}. This expert has contributed significantly to the field and brings valuable insights to our platform.`;
            }
            
            // Set report image (changed from Authors webp to Reports webp)
            if (authorNumber) {
                image.src = `Reports webp/Report${authorNumber}.webp`;
                image.style.display = 'block';
            } else {
                image.style.display = 'none';
            }
            
            popup.style.display = 'block';
            
            // Disable camera controls and mouse following when popup is open
            controls.enabled = false;
            mouseFollowEnabled = false;
        }
        
        try {
            console.log("Three.js imported successfully");
            
            // Detect mobile device and setup gyro controls
            detectMobileDevice();

            // Scene, camera, renderer
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black background
            
            // Add black fog in the distance
            scene.fog = new THREE.Fog(0x000000, 80, 200);
            
            console.log("Scene created");
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 8, 500);
            camera.position.set(0, 5, 1);
            console.log("Camera created");
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                alpha: false,
                stencil: false,
                depth: false,
                logarithmicDepthBuffer: false,
                preserveDrawingBuffer: false,
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Enhanced pixel ratio for better antialiasing
            const pixelRatio = Math.min(window.devicePixelRatio, 1.5); // Cap at 2x for performance
            renderer.setPixelRatio(pixelRatio);
            
            // Enhanced rendering quality settings
            renderer.outputColorSpace = THREE.SRGBColorSpace; // Changed from LinearSRGBColorSpace to SRGBColorSpace for proper texture display
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // Slightly increased for better brightness with ambient light

            
            // Additional quality improvements
            renderer.sortObjects = true;
            renderer.autoClear = true;
            renderer.autoClearColor = true;
            renderer.autoClearDepth = true;
            renderer.autoClearStencil = true;
            
            // Disable shadows to eliminate potential line artifacts
            renderer.shadowMap.enabled = false;

            
            document.body.appendChild(renderer.domElement);
            console.log("Renderer created and added to DOM");
            
            // Set up enhanced post-processing with MSAA antialiasing
            composer = new EffectComposer(renderer);
            
            // Add the main render pass
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Add output pass for proper color space (this should be last)
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
            
            console.log("Enhanced post-processing with MSAA antialiasing initialized");

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Disable zoom functionality
            controls.enableZoom = false;
            
            // Disable mouse click camera movement
            controls.enableRotate = false;
            controls.enablePan = false;
            
            // Adjust orbital point up slightly and tilt camera up
            controls.target.set(0, 8, 0); // Move orbital point up
            camera.position.set(0, 5, 1); // Tilt camera up more
            controls.update();
            
            // Store original camera target and position for reset functionality
            originalCameraTarget = controls.target.clone();
            originalCameraPosition = camera.position.clone();
            
            console.log("Controls created with basic limits");


            // Add rim lighting from the front
            const rimLight = new THREE.DirectionalLight(0xffffff, 2);
            rimLight.position.set(0, 6, 30); // Far front for rim effect
            rimLight.castShadow = false;
            scene.add(rimLight);

            const rimLight2 = new THREE.DirectionalLight(0xffffff, 2);
            rimLight2.position.set(20, 6, 30); // Far front for rim effect
            rimLight2.castShadow = false;
            scene.add(rimLight2);
            
            const rimLight3 = new THREE.DirectionalLight(0xffffff, 2);
            rimLight3.position.set(-20, 6, 30); // Far front for rim effect
            rimLight3.castShadow = false;
            scene.add(rimLight3);

            const ambientLight = new THREE.AmbientLight(0xffffff, 4);
            scene.add(ambientLight);


            console.log("Enhanced lighting with multiple front-facing lights and ambient light added");

            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Mouse click event
            window.addEventListener('click', onMouseClick, false);
            
            // Mouse move event for hover cursor
            window.addEventListener('mousemove', onMouseMove, false);
            
            function onMouseMove(event) {
                // Update mouse position for camera following (always track, even when popup is open)
                mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
                mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Check if popup is open - if so, disable all hover effects
                const popupCard = document.getElementById('popup-card');
                if (popupCard.style.display === 'block') {
                    document.body.style.cursor = 'default';
                    return;
                }
                
                mouse.x = mousePosition.x;
                mouse.y = mousePosition.y;
                
                raycaster.setFromCamera(mouse, camera);
                
                // Check for author objects
                const authorIntersects = raycaster.intersectObjects(authorObjects, true);
                
                // Check for category objects
                const categoryIntersects = raycaster.intersectObjects(categoriesObjects, true);
                
                // Check for author text objects
                const authorTextIntersects = raycaster.intersectObjects(authorTextObjects, true);
                
                // Check for category title objects
                const categoryTitleIntersects = raycaster.intersectObjects(categoriesTitleObjects, true);
                
                // Helper function to find category group from any object
                function findCategoryGroupFromObject(object) {
                    // Check each category group to see if this object belongs to it
                    for (const [groupNum, group] of Object.entries(categoryGroups)) {
                        if (group.category === object || 
                            group.categoryTitle === object ||
                            group.authors.includes(object) || 
                            group.authorTexts.includes(object)) {
                            return { groupNum, categoryObject: group.category };
                        }
                        
                        // Also check parent objects for nested meshes
                        let parent = object.parent;
                        while (parent) {
                            if (group.category === parent || 
                                group.categoryTitle === parent ||
                                group.authors.includes(parent) || 
                                group.authorTexts.includes(parent)) {
                                return { groupNum, categoryObject: group.category };
                            }
                            parent = parent.parent;
                        }
                    }
                    return null;
                }
                
                if (authorIntersects.length > 0) {
                    // Hovering over an author object - show pointer cursor and apply category hover
                    document.body.style.cursor = 'pointer';
                    
                    const authorObject = authorIntersects[0].object;
                    let targetAuthor = authorObject;
                    
                    // Find parent author object if clicked on child
                    let parent = authorObject.parent;
                    while (parent && !parent.name.toLowerCase().includes('author')) {
                        parent = parent.parent;
                    }
                    if (parent && parent.name.toLowerCase().includes('author')) {
                        targetAuthor = parent;
                    }
                    
                    const groupInfo = findCategoryGroupFromObject(targetAuthor);
                    if (groupInfo && hoveredCategory !== groupInfo.categoryObject) {
                        resetCategoryHover();
                        if (lockedCategory !== groupInfo.groupNum) {
                            applyCategoryHover(groupInfo.categoryObject);
                        }
                    }
                } else if (categoryIntersects.length > 0 || authorTextIntersects.length > 0 || 
                          categoryTitleIntersects.length > 0) {
                    // Hovering over any group object - show pointer cursor and apply category hover
                    document.body.style.cursor = 'pointer';
                    
                    let targetObject = null;
                    if (categoryIntersects.length > 0) targetObject = categoryIntersects[0].object;
                    else if (authorTextIntersects.length > 0) targetObject = authorTextIntersects[0].object;
                    else if (categoryTitleIntersects.length > 0) targetObject = categoryTitleIntersects[0].object;
                    
                    if (targetObject) {
                        const groupInfo = findCategoryGroupFromObject(targetObject);
                        if (groupInfo && hoveredCategory !== groupInfo.categoryObject) {
                            resetCategoryHover();
                            if (lockedCategory !== groupInfo.groupNum) {
                                applyCategoryHover(groupInfo.categoryObject);
                            }
                        }
                    }
                } else {
                    // Not hovering over any interactive object - show default cursor
                    document.body.style.cursor = 'default';
                    resetCategoryHover();
                }
            }
            
            function applyCategoryHover(categoryObject) {
                hoveredCategory = categoryObject;
                
                // Find which category group this belongs to
                const categoryNum = Object.keys(categoryGroups).find(num => 
                    categoryGroups[num].category === categoryObject
                );
                
                if (!categoryNum) return;
                
                // Don't apply hover if this category is locked
                if (lockedCategory === categoryNum) {
                    hoveredCategory = null;
                    return;
                }
                
                const group = categoryGroups[categoryNum];
                
                // First reset all objects to their original rotations to prevent accumulation
                resetGroupToOriginalRotations(categoryNum);
                
                // Calculate direction to camera
                const categoryPosition = new THREE.Vector3();
                categoryObject.getWorldPosition(categoryPosition);
                
                const cameraPosition = camera.position.clone();
                const direction = cameraPosition.sub(categoryPosition).normalize();
                
                // Create rotation to face camera (Y-axis only) with reduced rotation
                let targetYRotation = Math.atan2(direction.x, direction.z);
                
                // Normalize the angle to prevent over-rotation
                while (targetYRotation > Math.PI) targetYRotation -= 2 * Math.PI;
                while (targetYRotation < -Math.PI) targetYRotation += 2 * Math.PI;
                
                // Apply a reduction factor to prevent over-rotation
                const originalY = group.originalRotations.category.y;
                let rotationDifference = targetYRotation - originalY;
                
                // Normalize the difference
                while (rotationDifference > Math.PI) rotationDifference -= 2 * Math.PI;
                while (rotationDifference < -Math.PI) rotationDifference += 2 * Math.PI;
                
                // Reduce the rotation by 30% for hover (more subtle than click)
                rotationDifference *= 0.7;
                
                // Calculate rotation difference (Y-axis only)
                const rotationDiff = {
                    x: 0, // No X rotation
                    y: rotationDifference,
                    z: 0  // No Z rotation
                };
                
                // Animate rotation for entire group
                animateCategoryGroupRotation(categoryNum, rotationDiff);
            }
            
            function resetGroupToOriginalRotations(categoryNum) {
                const group = categoryGroups[categoryNum];
                if (!group) return;
                
                // Reset category
                group.category.rotation.x = group.originalRotations.category.x;
                group.category.rotation.y = group.originalRotations.category.y;
                group.category.rotation.z = group.originalRotations.category.z;
                
                // Reset category title
                if (group.categoryTitle) {
                    group.categoryTitle.rotation.x = group.originalRotations.categoryTitle.x;
                    group.categoryTitle.rotation.y = group.originalRotations.categoryTitle.y;
                    group.categoryTitle.rotation.z = group.originalRotations.categoryTitle.z;
                }
                
                // Reset authors
                group.authors.forEach((author) => {
                    const authorName = author.name;
                    if (group.originalRotations[authorName]) {
                        author.rotation.x = group.originalRotations[authorName].x;
                        author.rotation.y = group.originalRotations[authorName].y;
                        author.rotation.z = group.originalRotations[authorName].z;
                    }
                });
                
                // Reset author texts
                group.authorTexts.forEach((authorText) => {
                    const authorTextName = authorText.name;
                    if (group.originalRotations[authorTextName]) {
                        authorText.rotation.x = group.originalRotations[authorTextName].x;
                        authorText.rotation.y = group.originalRotations[authorTextName].y;
                        authorText.rotation.z = group.originalRotations[authorTextName].z;
                    }
                });
            }
            
            function resetCategoryHover() {
                if (hoveredCategory) {
                    // Find which category group this belongs to
                    const categoryNum = Object.keys(categoryGroups).find(num => 
                        categoryGroups[num].category === hoveredCategory
                    );
                    
                    // Only reset if this category is not locked
                    if (categoryNum && lockedCategory !== categoryNum) {
                        // Animate back to original rotations for entire group
                        animateCategoryGroupRotation(categoryNum, { x: 0, y: 0, z: 0 }, true);
                    }
                    
                    hoveredCategory = null;
                }
            }
            
            function animateCategoryGroupRotation(categoryNum, rotationDiff, resetToOriginal = false) {
                const group = categoryGroups[categoryNum];
                if (!group) return;
                
                // Store starting rotations for all objects in group
                const startRotations = {};
                
                // Category
                startRotations.category = {
                    x: group.category.rotation.x,
                    y: group.category.rotation.y,
                    z: group.category.rotation.z
                };
                
                // Text
                if (group.text) {
                    startRotations.text = {
                        x: group.text.rotation.x,
                        y: group.text.rotation.y,
                        z: group.text.rotation.z
                    };
                }
                
                // Category Title
                if (group.categoryTitle) {
                    startRotations.categoryTitle = {
                        x: group.categoryTitle.rotation.x,
                        y: group.categoryTitle.rotation.y,
                        z: group.categoryTitle.rotation.z
                    };
                }
                
                // Authors
                group.authors.forEach((author, index) => {
                    startRotations[`author${index}`] = {
                        x: author.rotation.x,
                        y: author.rotation.y,
                        z: author.rotation.z
                    };
                });
                
                // Author Texts
                group.authorTexts.forEach((authorText, index) => {
                    startRotations[`authorText${index}`] = {
                        x: authorText.rotation.x,
                        y: authorText.rotation.y,
                        z: authorText.rotation.z
                    };
                });
                
                const duration = 300; // 300ms animation
                const startTime = Date.now();
                
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Smooth easing
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    if (resetToOriginal) {
                        // Reset to original rotations
                        group.category.rotation.x = startRotations.category.x + (group.originalRotations.category.x - startRotations.category.x) * easeOut;
                        group.category.rotation.y = startRotations.category.y + (group.originalRotations.category.y - startRotations.category.y) * easeOut;
                        group.category.rotation.z = startRotations.category.z + (group.originalRotations.category.z - startRotations.category.z) * easeOut;
                        
                        if (group.text) {
                            group.text.rotation.x = startRotations.text.x + (group.originalRotations.text.x - startRotations.text.x) * easeOut;
                            group.text.rotation.y = startRotations.text.y + (group.originalRotations.text.y - startRotations.text.y) * easeOut;
                            group.text.rotation.z = startRotations.text.z + (group.originalRotations.text.z - startRotations.text.z) * easeOut;
                        }
                        
                        if (group.categoryTitle) {
                            group.categoryTitle.rotation.x = startRotations.categoryTitle.x + (group.originalRotations.categoryTitle.x - startRotations.categoryTitle.x) * easeOut;
                            group.categoryTitle.rotation.y = startRotations.categoryTitle.y + (group.originalRotations.categoryTitle.y - startRotations.categoryTitle.y) * easeOut;
                            group.categoryTitle.rotation.z = startRotations.categoryTitle.z + (group.originalRotations.categoryTitle.z - startRotations.categoryTitle.z) * easeOut;
                        }
                        
                        group.authors.forEach((author, index) => {
                            const authorName = author.name;
                            if (group.originalRotations[authorName]) {
                                author.rotation.x = startRotations[`author${index}`].x + (group.originalRotations[authorName].x - startRotations[`author${index}`].x) * easeOut;
                                author.rotation.y = startRotations[`author${index}`].y + (group.originalRotations[authorName].y - startRotations[`author${index}`].y) * easeOut;
                                author.rotation.z = startRotations[`author${index}`].z + (group.originalRotations[authorName].z - startRotations[`author${index}`].z) * easeOut;
                            }
                        });
                        
                        group.authorTexts.forEach((authorText, index) => {
                            const authorTextName = authorText.name;
                            if (group.originalRotations[authorTextName]) {
                                authorText.rotation.x = startRotations[`authorText${index}`].x + (group.originalRotations[authorTextName].x - startRotations[`authorText${index}`].x) * easeOut;
                                authorText.rotation.y = startRotations[`authorText${index}`].y + (group.originalRotations[authorTextName].y - startRotations[`authorText${index}`].y) * easeOut;
                                authorText.rotation.z = startRotations[`authorText${index}`].z + (group.originalRotations[authorTextName].z - startRotations[`authorText${index}`].z) * easeOut;
                            }
                        });
                    } else {
                        // Apply rotation difference to all objects using consistent starting rotations
                        group.category.rotation.x = group.originalRotations.category.x + rotationDiff.x * easeOut;
                        group.category.rotation.y = group.originalRotations.category.y + rotationDiff.y * easeOut;
                        group.category.rotation.z = group.originalRotations.category.z + rotationDiff.z * easeOut;
                        
                        if (group.text) {
                            group.text.rotation.x = group.originalRotations.text.x + rotationDiff.x * easeOut;
                            group.text.rotation.y = group.originalRotations.text.y + rotationDiff.y * easeOut;
                            group.text.rotation.z = group.originalRotations.text.z + rotationDiff.z * easeOut;
                        }
                        
                        if (group.categoryTitle) {
                            group.categoryTitle.rotation.x = group.originalRotations.categoryTitle.x + rotationDiff.x * easeOut;
                            group.categoryTitle.rotation.y = group.originalRotations.categoryTitle.y + rotationDiff.y * easeOut;
                            group.categoryTitle.rotation.z = group.originalRotations.categoryTitle.z + rotationDiff.z * easeOut;
                        }
                        
                        group.authors.forEach((author, index) => {
                            const authorName = author.name;
                            if (group.originalRotations[authorName]) {
                                author.rotation.x = group.originalRotations[authorName].x + rotationDiff.x * easeOut;
                                author.rotation.y = group.originalRotations[authorName].y + rotationDiff.y * easeOut;
                                author.rotation.z = group.originalRotations[authorName].z + rotationDiff.z * easeOut;
                            }
                        });
                        
                        group.authorTexts.forEach((authorText, index) => {
                            const authorTextName = authorText.name;
                            if (group.originalRotations[authorTextName]) {
                                authorText.rotation.x = group.originalRotations[authorTextName].x + rotationDiff.x * easeOut;
                                authorText.rotation.y = group.originalRotations[authorTextName].y + rotationDiff.y * easeOut;
                                authorText.rotation.z = group.originalRotations[authorTextName].z + rotationDiff.z * easeOut;
                            }
                        });
                    }
                    
                    // Manually update matrices since matrixAutoUpdate is disabled
                    group.category.updateMatrix();
                    if (group.text) group.text.updateMatrix();
                    if (group.categoryTitle) group.categoryTitle.updateMatrix();
                    group.authors.forEach(author => author.updateMatrix());
                    group.authorTexts.forEach(authorText => authorText.updateMatrix());
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                }
                
                animate();
            }
            
            function onMouseClick(event) {
                // Check if popup is open - if so, only allow closing it
                const popupElement = document.getElementById('popup-card');
                if (popupElement.style.display === 'block') {
                    // Only close popup if clicking outside of it
                    const popupRect = popupElement.getBoundingClientRect();
                    const clickX = event.clientX;
                    const clickY = event.clientY;
                    
                    if (clickX < popupRect.left || clickX > popupRect.right || 
                        clickY < popupRect.top || clickY > popupRect.bottom) {
                        closePopup();
                    }
                    return;
                }
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                // Check for author objects first
                const authorIntersects = raycaster.intersectObjects(authorObjects, true);
                
                if (authorIntersects.length > 0) {
                    const clickedObject = authorIntersects[0].object;
                    let authorName = clickedObject.name;
                    let authorObject = clickedObject;
                    
                    // Find parent object name if clicked on child
                    let parent = clickedObject.parent;
                    while (parent && !parent.name.toLowerCase().includes('author')) {
                        parent = parent.parent;
                    }
                    if (parent && parent.name.toLowerCase().includes('author')) {
                        authorName = parent.name;
                        authorObject = parent;
                    }
                    
                    showPopup(authorName, authorObject);
                    return;
                }
                
                // Check for category objects
                const categoryIntersects = raycaster.intersectObjects(categoriesObjects, true);
                
                if (categoryIntersects.length > 0) {
                    const clickedObject = categoryIntersects[0].object;
                    let categoryObject = clickedObject;
                    
                    // Find parent category object
                    let parent = clickedObject.parent;
                    while (parent && !parent.name.includes('Categories')) {
                        parent = parent.parent;
                    }
                    if (parent && parent.name.includes('Categories')) {
                        categoryObject = parent;
                    }
                    
                    // Find which category group this belongs to
                    const categoryNum = Object.keys(categoryGroups).find(num => 
                        categoryGroups[num].category === categoryObject
                    );
                    
                    if (categoryNum) {
                        // Reset any hover effects first to prevent accumulation
                        resetCategoryHover();
                        
                        // Reset any previously locked category
                        if (lockedCategory && lockedCategory !== categoryNum) {
                            resetCategoryToOriginal(lockedCategory);
                        }
                        
                        // Lock this category facing the camera (without hover interference)
                        lockCategoryFacingCamera(categoryNum);
                        
                        // Tilt camera towards the category
                        tiltCameraToCategory(categoryObject);
                    }
                    return;
                }
                
                // Clicked elsewhere - reset everything and return camera to original view
                const popup = document.getElementById('popup-card');
                if (popup.style.display === 'block') {
                    closePopup();
                }
                
                // Only reset camera if there's a locked category or if mouse following is not active
                // This prevents accidental camera reset when mouse following is working
                if (lockedCategory) {
                    // Reset any locked category when clicking elsewhere
                    resetCategoryToOriginal(lockedCategory);
                    lockedCategory = null;
                
                    // Simply reset camera to default view without tilt animation
                    resetCameraToDefault();
                } else if (!mouseFollowEnabled || cameraTransitioning) {
                    // Only reset camera view if mouse following is disabled or camera is transitioning
                    resetCameraView();
                }
                // If mouse following is active and no category is locked, do nothing (let mouse following continue)
            }
            
            function tiltCameraToCategory(categoryObject) {
                // Disable mouse following and mark as transitioning
                mouseFollowEnabled = false;
                cameraTransitioning = true;
                
                // Get category world position
                const categoryPosition = new THREE.Vector3();
                categoryObject.getWorldPosition(categoryPosition);
                
                // Store current camera position and target
                const currentPosition = camera.position.clone();
                const currentTarget = controls.target.clone();
                
                // Calculate new target for camera to look at
                const newTarget = categoryPosition.clone();
                
                // Calculate zoom-in position (move camera closer to the target)
                const direction = currentPosition.clone().sub(newTarget).normalize();
                const zoomDistance = currentPosition.distanceTo(newTarget) * 0.7; // Zoom in to 70% of original distance
                const newPosition = newTarget.clone().add(direction.multiplyScalar(zoomDistance));
                
                // Animate camera tilt and zoom
                const duration = 1000; // 1 second animation
                const startTime = Date.now();
                
                function animateTiltAndZoom() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Smooth easing
                    const easeInOut = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    // Interpolate target position
                    controls.target.lerpVectors(currentTarget, newTarget, easeInOut);
                    
                    // Interpolate camera position (zoom in)
                    camera.position.lerpVectors(currentPosition, newPosition, easeInOut);
                    
                    controls.update();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateTiltAndZoom);
                    } else {
                        // Tilt complete - camera is now locked to category
                        cameraTransitioning = false;
                        console.log(`Camera tilted and zoomed to focus on: ${categoryObject.name}`);
                    }
                }
                
                animateTiltAndZoom();
            }
            
            function lockCategoryFacingCamera(categoryNum) {
                const group = categoryGroups[categoryNum];
                if (!group) return;
                
                // First reset to original rotations to avoid accumulation
                resetGroupToOriginalRotations(categoryNum);
                
                // Calculate direction to camera from original position
                const categoryPosition = new THREE.Vector3();
                group.category.getWorldPosition(categoryPosition);
                
                const cameraPosition = camera.position.clone();
                const direction = cameraPosition.sub(categoryPosition).normalize();
                
                // Create rotation to face camera (Y-axis only) with reduced rotation
                let targetYRotation = Math.atan2(direction.x, direction.z);
                
                // Normalize the angle to prevent over-rotation
                while (targetYRotation > Math.PI) targetYRotation -= 2 * Math.PI;
                while (targetYRotation < -Math.PI) targetYRotation += 2 * Math.PI;
                
                // Apply a reduction factor to prevent over-rotation
                const originalY = group.originalRotations.category.y;
                let rotationDifference = targetYRotation - originalY;
                
                // Normalize the difference
                while (rotationDifference > Math.PI) rotationDifference -= 2 * Math.PI;
                while (rotationDifference < -Math.PI) rotationDifference += 2 * Math.PI;
                
                // Reduce the rotation by 20% to prevent over-rotation
                rotationDifference *= 0.8;
                
                // Calculate final rotation difference (Y-axis only)
                const rotationDiff = {
                    x: 0,
                    y: rotationDifference,
                    z: 0
                };
                
                // Apply rotation to entire group and lock it
                animateCategoryGroupRotation(categoryNum, rotationDiff);
                lockedCategory = categoryNum;
                
                // Disable mouse following when a category is locked
                mouseFollowEnabled = false;
                
                console.log(`Category ${categoryNum} locked facing camera with reduced rotation`);
            }
            
            function resetCategoryToOriginal(categoryNum) {
                const group = categoryGroups[categoryNum];
                if (!group) return;
                
                // Animate back to original rotations for entire group
                animateCategoryGroupRotation(categoryNum, { x: 0, y: 0, z: 0 }, true);
                
                console.log(`Category ${categoryNum} reset to original rotation`);
            }
            
            function resetCameraView() {
                if (!originalCameraTarget || !originalCameraPosition) return;
                
                // Disable mouse following and mark as transitioning
                mouseFollowEnabled = false;
                cameraTransitioning = true;
                
                // Store current target and position
                const currentTarget = controls.target.clone();
                const currentPosition = camera.position.clone();
                
                // Animate camera target and position back to original
                const duration = 1000; // 1 second animation
                const startTime = Date.now();
                
                function animateReset() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Smooth easing
                    const easeInOut = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    // Interpolate target position back to original
                    controls.target.lerpVectors(currentTarget, originalCameraTarget, easeInOut);
                    
                    // Interpolate camera position back to original (zoom out)
                    camera.position.lerpVectors(currentPosition, originalCameraPosition, easeInOut);
                    
                    controls.update();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateReset);
                    } else {
                        // Reset complete - prepare for smooth transition to mouse following
                        targetCameraPosition = originalCameraPosition.clone();
                        cameraTransitioning = false;
                        
                        // Start smooth transition to mouse following after a brief delay
                        setTimeout(() => {
                            if (cameraAnimationComplete && !lockedCategory) {
                                // Ensure camera is exactly at original position before transitioning
                                camera.position.copy(originalCameraPosition);
                                controls.target.copy(originalCameraTarget);
                                controls.update();
                                
                                smoothTransitionToMouseFollow();
                            }
                        }, 150); // Slightly longer delay to ensure reset is complete
                        
                        console.log("Camera view and zoom reset to original position, preparing for mouse following");
                    }
                }
                
                animateReset();
            }

            // Animation loop
            function animate() {
                stats.begin(); // Start stats.js monitoring
                
                requestAnimationFrame(animate);
                
                // Update camera following if enabled and not transitioning
                if (cameraAnimationComplete && !lockedCategory && !cameraTransitioning) {
                    if (isMobile && touchEnabled) {
                        // Touch controls are handled in the touch event handlers
                        // No additional processing needed here
                    } else if (mouseFollowEnabled) {
                        // Desktop mouse following
                        updateCameraFollowMouse();
                    }
                }
                
                controls.update();
                composer.render(); // Use composer instead of renderer.render
                
                stats.end(); // End stats.js monitoring
            }
            
            // Start animation
            animate();
            console.log("Animation started");

            // Load text and links configuration
            loadTextAndLinksConfig();
            
            // Load author textures
            loadAuthorTextures();
            
            // Load the 3D model directly
            loadModel();
            
            function loadAuthorTextures() {
                performanceStats.textureLoadStart = performance.now();
                const textureLoader = new THREE.TextureLoader();
                
                // Load textures for Author1 through Author8
                for (let i = 1; i <= 8; i++) {
                    textureLoader.load(
                        `Authors webp/Author${i}.webp`,
                    function(texture) {
                            // Fix upside-down texture by flipping Y
                            texture.flipY = false;
                            texture.wrapS = THREE.ClampToEdgeWrapping;
                            texture.wrapT = THREE.ClampToEdgeWrapping;
                            
                            // Set proper color space for accurate color reproduction
                            texture.colorSpace = THREE.SRGBColorSpace;
                            
                            authorTextures[i] = texture;
                            texturesLoaded++;
                            console.log(`Author${i} texture loaded successfully`);
                            
                            // Check if all textures are loaded and model is loaded
                            if (texturesLoaded === 8 && modelLoaded) {
                                performanceStats.textureLoadEnd = performance.now();
                                applyTexturesToAuthors();
                            }
                    },
                    function(xhr) {
                            // Progress callback
                    },
                    function(error) {
                            console.error(`Error loading Author${i} texture:`, error);
                            texturesLoaded++; // Count failed loads too
                            if (texturesLoaded === 8 && modelLoaded) {
                                performanceStats.textureLoadEnd = performance.now();
                                applyTexturesToAuthors();
                            }
                        }
                    );
                }
            }
            
            function createCategoryGroups() {
                console.log("Creating category groups...");
                
                // Helper function to extract number from object name
                function getObjectNumber(objectName) {
                    const match = objectName.match(/(\d+)$/);
                    return match ? parseInt(match[1]) : null;
                }
                
                // Helper function to determine which category group an object belongs to based on ending number
                function getCategoryGroupForNumber(number) {
                    if (number === 1 || number === 2) return 1;
                    if (number === 3 || number === 4) return 2;
                    if (number === 5 || number === 6) return 3;
                    if (number === 7 || number === 8) return 4;
                    return null;
                }
                
                // Initialize category groups
                for (let i = 1; i <= 4; i++) {
                    const categoryObject = categoriesObjects.find(cat => 
                        cat.name.includes(`Categories${i}`)
                    );
                    
                    if (categoryObject) {
                        categoryGroups[i] = {
                            category: categoryObject,
                            categoryTitle: null,
                            authors: [],
                            authorTexts: [],
                            originalRotations: {} // Store original rotations for reset
                        };
                        
                        // Store category's original rotation
                        categoryGroups[i].originalRotations.category = {
                            x: categoryObject.rotation.x,
                            y: categoryObject.rotation.y,
                            z: categoryObject.rotation.z
                        };
                    }
                }
                

                // Group category title objects (direct 1-to-1 mapping)
                categoriesTitleObjects.forEach(categoryTitleObject => {
                    const objectNumber = getObjectNumber(categoryTitleObject.name);
                    
                    // CategoriesTitle objects map directly to their category number
                    if (objectNumber && categoryGroups[objectNumber]) {
                        categoryGroups[objectNumber].categoryTitle = categoryTitleObject;
                        categoryGroups[objectNumber].originalRotations.categoryTitle = {
                            x: categoryTitleObject.rotation.x,
                            y: categoryTitleObject.rotation.y,
                            z: categoryTitleObject.rotation.z
                        };
                        console.log(`Grouped ${categoryTitleObject.name} (number ${objectNumber}) with Categories${objectNumber}`);
                    }
                });
                
                // Group author objects
                authorObjects.forEach(authorObject => {
                    const objectNumber = getObjectNumber(authorObject.name);
                    const categoryGroup = getCategoryGroupForNumber(objectNumber);
                    
                    if (categoryGroup && categoryGroups[categoryGroup]) {
                        categoryGroups[categoryGroup].authors.push(authorObject);
                        categoryGroups[categoryGroup].originalRotations[authorObject.name] = {
                                    x: authorObject.rotation.x,
                                    y: authorObject.rotation.y,
                                    z: authorObject.rotation.z
                                };
                        console.log(`Grouped ${authorObject.name} (ending with ${objectNumber}) with Categories${categoryGroup}`);
                    }
                });
                
                // Group author text objects
                authorTextObjects.forEach(authorTextObject => {
                    const objectNumber = getObjectNumber(authorTextObject.name);
                    const categoryGroup = getCategoryGroupForNumber(objectNumber);
                    
                    if (categoryGroup && categoryGroups[categoryGroup]) {
                        categoryGroups[categoryGroup].authorTexts.push(authorTextObject);
                        categoryGroups[categoryGroup].originalRotations[authorTextObject.name] = {
                            x: authorTextObject.rotation.x,
                            y: authorTextObject.rotation.y,
                            z: authorTextObject.rotation.z
                        };
                        console.log(`Grouped ${authorTextObject.name} (ending with ${objectNumber}) with Categories${categoryGroup}`);
                    }
                });
                
                // Log final group summary
                Object.keys(categoryGroups).forEach(categoryNum => {
                    const group = categoryGroups[categoryNum];
                    console.log(`Category group ${categoryNum} created with:`);
                    console.log(`  - ${group.authors.length} authors: ${group.authors.map(a => a.name).join(', ')}`);
                    console.log(`  - ${group.authorTexts.length} author texts: ${group.authorTexts.map(a => a.name).join(', ')}`);
                    console.log(`  - Category title: ${group.categoryTitle ? group.categoryTitle.name : 'not found'}`);
                });
            }

            function applyTexturesToAuthors() {
                console.log("Applying textures to author objects...");
                authorObjects.forEach(authorObject => {
                    const authorNumber = authorObject.name.replace(/\D/g, '');
                    if (authorNumber && authorTextures[authorNumber]) {
                        // Clone the texture to modify it independently
                        const enhancedTexture = authorTextures[authorNumber].clone();
                        enhancedTexture.needsUpdate = true;
                        
                        // Create dedicated unlit material for this author with enhanced saturation and lower exposure
                        const authorMaterial = new THREE.MeshBasicMaterial({
                            map: enhancedTexture, // Use enhanced texture
                            transparent: false,
                            opacity: 1.0,
                            side: THREE.FrontSide,
                            toneMapped: true, // Enable tone mapping for exposure control
                        });
                        
                        // Apply the dedicated material to all meshes in the author object
                        authorObject.traverse((child) => {
                            if (child.isMesh) {
                                const materialClone = authorMaterial.clone();
                                

                                
                                // The texture will be affected by tone mapping and exposure settings
                                child.material = materialClone;
                                child.material.needsUpdate = true;
                            }
                        });
                        console.log(`Applied Author${authorNumber} enhanced material with increased saturation and lower exposure`);
                    }
                });
            }
            
            function applyTextTexturesToAuthorText() {
                console.log("Applying text textures to AuthorText objects...");
                authorTextObjects.forEach(authorTextObject => {
                    const authorNumber = authorTextObject.name.replace(/\D/g, '');
                    if (authorNumber && authorTextTextures[authorNumber]) {
                        // Create material with text as opacity map
                        const textMaterial = new THREE.MeshLambertMaterial({
                            color: 0xffffff, // White base color
                            alphaMap: authorTextTextures[authorNumber], // Use text texture as opacity
                            transparent: true,
                            opacity: 0.9, // Slightly reduce opacity for better blending
                            side: THREE.DoubleSide,
                            toneMapped: false, // Prevent tone mapping
                            depthWrite: false, // Prevent z-fighting
                            alphaTest: 0.1 // Improve edge quality
                        });
                        
                        // Apply the material to all meshes in the AuthorText object
                        authorTextObject.traverse((child) => {
                            if (child.isMesh) {
                                child.material = textMaterial.clone();
                                child.material.needsUpdate = true;
                                
                                // Ensure proper rendering order
                                child.renderOrder = 1;
                            }
                        });
                        console.log(`Applied text texture to AuthorText${authorNumber}`);
                    }
                });
            }
            
            function applyTextTexturesToCategoriesTitle() {
                console.log("Applying text textures to CategoriesTitle objects...");
                categoriesTitleObjects.forEach(categoryTitleObject => {
                    const categoryNumber = categoryTitleObject.name.replace(/\D/g, '');
                    if (categoryNumber && categoryTitleTextures[categoryNumber]) {
                        // Create material with text as opacity map
                        const textMaterial = new THREE.MeshLambertMaterial({
                            color: 0xffffff, // White base color
                            alphaMap: categoryTitleTextures[categoryNumber], // Use text texture as opacity
                            transparent: true,
                            opacity: 0.9, // Slightly reduce opacity for better blending
                            side: THREE.DoubleSide,
                            toneMapped: false, // Prevent tone mapping
                            depthWrite: false, // Prevent z-fighting
                            alphaTest: 0.1 // Improve edge quality
                        });
                        
                        // Apply the material to all meshes in the CategoriesTitle object
                        categoryTitleObject.traverse((child) => {
                            if (child.isMesh) {
                                child.material = textMaterial.clone();
                                child.material.needsUpdate = true;
                                
                                // Ensure proper rendering order
                                child.renderOrder = 1;
                            }
                        });
                        console.log(`Applied text texture to CategoriesTitle${categoryNumber}`);
                    }
                });
            }

            function loadModel() {
                console.log("Starting to load GLB model...");
                performanceStats.modelLoadStart = performance.now();
                const loader = new GLTFLoader();
                loader.load(
                    'Stage.glb',
                    function(gltf) {
                        performanceStats.modelLoadEnd = performance.now();
                        console.log("Model loaded successfully");
                        const model = gltf.scene;
                        
                        // Center the model
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        model.position.sub(center);
                        model.position.y = 0;
                        
                        model.traverse((child) => {
                            if (child.name && child.name.trim() !== '') {
                                console.log("Found object:", child.name, "Type:", child.type);
                            }
                            
                            // Disable shadows for all meshes
                            if (child.isMesh) {
                                child.castShadow = false;
                                child.receiveShadow = false;
                            }
                            
                                
                                if (child.name === 'Floor') {
                                    // Apply basic material to Floor object
                                    
                                    // Replace with completely new MeshStandardMaterial
                                    const FloorMaterial = new THREE.MeshStandardMaterial({
                                        color: 0x2b2b2b,
                                        metalness: 0.8,
                                        roughness: 0.01,
                                        envMapIntensity: 0
                                    });
                                    
                                    // Apply the material to all meshes in the Floor object
                                    child.traverse((mesh) => {
                                        if (mesh.isMesh) {
                                            mesh.material = FloorMaterial.clone();
                                            console.log("Applied Floor material to mesh:", mesh.name);
                                        }
                                    });
                                }
                                else if (child.name === 'Stage') {
                                    // Make Stage emissive using original texture as emissive map
                                    if (child.isMesh && child.material) {
                                        const originalMaterial = child.material;
                                        const StageMaterial = new THREE.MeshStandardMaterial({
                                            map: originalMaterial.map, // Use original diffuse map
                                            emissiveMap: originalMaterial.map, // Use same texture as emissive
                                            emissive: new THREE.Color(0xffffff), // White to show texture properly
                                            emissiveIntensity: 0, // Reduced from 5 for better balance
                                            metalness: 0,
                                            roughness: 1,
                                            toneMapped: true,
                                        });
                                        child.material = StageMaterial;
                                        console.log("Applied emissive material with texture map to Stage");
                                    }
                                    
                                    // Create actual lights from Stage geometry
                                    createStageLight(child);
                                }


                            
                            if (child.name.toLowerCase().includes('author')) {
                                if (child.name.toLowerCase().includes('authortext')) {
                                    authorTextObjects.push(child);
                                    console.log("Found AuthorText object:", child.name);
                                } else {
                                authorObjects.push(child);
                                console.log("Found Author object:", child.name);
                                

                                }
                            }
                            
                            if (child.name.toLowerCase().includes('categoriestitle')) {
                                categoriesTitleObjects.push(child);
                                console.log("Found CategoriesTitle object:", child.name);
                            }
                            
                            if (child.name.includes('Categories')) {
                                categoriesObjects.push(child);
                                console.log("Found Categories object:", child.name);
                                
                                // Apply enhanced glass material with optimal transmission and black tint
                                const glassMaterial = new THREE.MeshPhysicalMaterial({
                                    color: 0x1a1a1a, // Almost black tint instead of white
                                    metalness: 0.6,
                                    roughness: 0.25, // Smoother surface
                                    transmission: 1, // Full transmission
                                    transparent: true,
                                    opacity: 0.95,
                                    ior: 1.42, // Glass IOR
                                    thickness: 1, // Increased thickness for better transmission
                                    dispersion: 1.0, // Maximum dispersion for rainbow effect
                                    clearcoat: 0.0, // Small amount for surface reflection
                                    clearcoatRoughness: 0.0,
                                    envMapIntensity: 0.2, // Minimal environment reflections
                                    reflectivity: 0.25, // Reduced reflectivity
                                    attenuationDistance: 2, // Slightly reduced for more visible tint
                                    attenuationColor: new THREE.Color(0x0a0a0a) // Dark gray for subtle black tinting
                                });
                                
                                // Apply to all meshes in the Categories object
                                child.traverse((mesh) => {
                                    if (mesh.isMesh) {
                                        mesh.material = glassMaterial.clone();
                                        console.log("Applied tinted glass material to mesh:", mesh.name);
                                    }
                                });
                            }
                        });
                        
                        scene.add(model);
                        console.log("Model added to scene");
                        
                        // Disable matrix auto update for performance optimization
                        model.traverse((child) => {
                            if (child.isMesh || child.isGroup || child.isObject3D) {
                                child.matrixAutoUpdate = false;
                                child.updateMatrix(); // Update matrix one final time
                            }
                        });
                        console.log("Matrix auto update disabled for all model objects");
                        
                        // Count triangles for performance stats
                        performanceStats.triangleCount = countTriangles(model);
                        console.log(`Model triangle count: ${performanceStats.triangleCount.toLocaleString()}`);
                        
                        // Create category groups
                        createCategoryGroups();
                        
                        // Set model loaded flag and apply textures if ready
                        modelLoaded = true;
                        if (texturesLoaded === 8) {
                            applyTexturesToAuthors();
                        }
                        
                        // Apply text textures to AuthorText and CategoriesTitle objects
                        applyTextTexturesToAuthorText();
                        applyTextTexturesToCategoriesTitle();
                        
                        // Adjust camera to fit the entire model
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const fov = camera.fov * (Math.PI / 180);
                        let cameraDistance = maxDim / (2 * Math.tan(fov / 2));
                        
                        cameraDistance *= 0.12; // Increased from 0.07 to move camera further away
                        
                        // Store final camera position
                        const finalCameraPosition = new THREE.Vector3(0, 5, cameraDistance);
                        
                        // Set initial camera position (much further back for longer animation)
                        const initialCameraPosition = new THREE.Vector3(0, 5, cameraDistance * 4.5);
                        camera.position.copy(initialCameraPosition);
                        controls.update();
                        
                        // Animate camera to final position
                        const animationDuration = 4500; // Extended to 4.5 seconds
                        const startTime = Date.now();
                        
                        function animateCamera() {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / animationDuration, 1);
                            
                            // Smooth easing function (ease-out)
                            const easeOut = 1 - Math.pow(1 - progress, 3);
                            
                            // Interpolate camera position
                            camera.position.lerpVectors(initialCameraPosition, finalCameraPosition, easeOut);
                            controls.update();
                            
                            if (progress < 1) {
                                requestAnimationFrame(animateCamera);
                            } else {
                                // Animation complete - store final camera position
                                originalCameraPosition = camera.position.clone(); // Update stored position after animation
                                targetCameraPosition = originalCameraPosition.clone(); // Initialize target position
                                
                                // Enable camera animation complete flag and mouse following
                                cameraAnimationComplete = true;
                                mouseFollowEnabled = true;
                                
                                console.log("Camera animation complete, final position stored, and mouse following enabled");
                            }
                        }
                        
                        // Start camera animation
                        animateCamera();
                        
                        console.log("Camera animation started");
                    },
                    function(xhr) {
                        if (xhr.lengthComputable) {
                            const progress = (xhr.loaded / xhr.total) * 100;
                            console.log(`Model loading: ${Math.round(progress)}%`);
                        }
                    },
                    function(error) {
                        console.error('Error loading model:', error);
                    }
                );
            }

            // Handle window resize
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                
                // Update pixel ratio
                const newPixelRatio = Math.min(window.devicePixelRatio, 1.5);
                renderer.setPixelRatio(newPixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight); // Also resize composer
            });
            
        } catch (error) {
            console.error("Error:", error);
            document.body.innerHTML = `<div style="color: white; padding: 20px; font-family: Arial;">Error: ${error.message}</div>`;
        }

        // Mobile device detection and touch control functions
        function detectMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase()) ||
                      (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform));
            
            if (isMobile) {
                console.log("Mobile device detected");
                requestTouchPermission();
            }
        }
        
        function requestTouchPermission() {
            if (typeof TouchEvent !== 'undefined' && typeof TouchEvent.requestPermission === 'function') {
                // iOS 13+ permission request
                TouchEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            enableTouchControls();
                        } else {
                            console.log("Touch permission denied");
                        }
                    })
                    .catch(console.error);
            } else if (window.TouchEvent) {
                // Android and older iOS
                enableTouchControls();
            }
        }
        
        function enableTouchControls() {
            touchEnabled = true;
            console.log("Touch controls enabled");
            
            window.addEventListener('touchstart', handleTouchStart, { passive: true });
            window.addEventListener('touchmove', handleTouchMove, { passive: true });
            window.addEventListener('touchend', handleTouchEnd, { passive: true });
            
            // Disable mouse following on mobile when touch is active
            mouseFollowEnabled = false;
        }
        
        function handleTouchStart(event) {
            if (!touchEnabled || !cameraAnimationComplete || lockedCategory || cameraTransitioning) return;
            
            // Get touch start position
            touchStartPosition.x = event.touches[0].clientX;
            touchStartPosition.y = event.touches[0].clientY;
            touchCurrentPosition.x = touchStartPosition.x;
            touchCurrentPosition.y = touchStartPosition.y;
            isTouching = true;
        }
        
        function handleTouchMove(event) {
            if (!touchEnabled || !cameraAnimationComplete || lockedCategory || cameraTransitioning || !isTouching) return;
            
            // Get current touch position
            const currentX = event.touches[0].clientX;
            const currentY = event.touches[0].clientY;
            
            // Calculate movement delta from start position
            touchDelta.x = currentX - touchStartPosition.x;
            touchDelta.y = currentY - touchStartPosition.y;
            
            // Apply touch sensitivity and convert to normalized coordinates
            const sensitivity = 0.05; // Reduced for smoother control
            const maxMovement = 60; // Increased significantly for much wider horizontal range
            
            // Convert touch movement to camera offset (invert Y for natural feel)
            const offsetX = touchDelta.x * sensitivity;
            const offsetY = -touchDelta.y * sensitivity * 0.3; // Reduced vertical sensitivity even more
            
            // Clamp movements with much wider horizontal and restricted vertical range
            const clampedOffsetX = Math.max(-maxMovement, Math.min(maxMovement, offsetX));
            const clampedOffsetY = Math.max(-maxMovement * 0.15, Math.min(maxMovement * 0.15, offsetY)); // Much more restricted vertical (15% instead of 50%)
            
            // Apply to camera position
            if (originalCameraPosition) {
                if (!targetCameraPosition) {
                    targetCameraPosition = originalCameraPosition.clone();
                }
                
                const newTargetPosition = originalCameraPosition.clone();
                newTargetPosition.x += clampedOffsetX;
                newTargetPosition.y += clampedOffsetY;
                
                // Smooth interpolation
                const lerpFactor = 0.1;
                targetCameraPosition.lerp(newTargetPosition, lerpFactor);
                camera.position.copy(targetCameraPosition);
                
                // Adjust target slightly for dynamic feel
                const targetOffset = originalCameraTarget.clone();
                targetOffset.x += clampedOffsetX * 0.4;
                targetOffset.y += clampedOffsetY * 0.4;
                controls.target.lerp(targetOffset, lerpFactor);
            }
        }
        
        function handleTouchEnd(event) {
            isTouching = false;
            touchDelta.x = 0;
            touchDelta.y = 0;
        }
        
        // Function to create lights from Stage object geometry
        function createStageLight(stageObject) {
            if (!stageObject) return;
            
            // Get the bounding box of the stage object
            const box = new THREE.Box3().setFromObject(stageObject);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            // Extract color from stage material texture
            let lightColor = 0xffffff; // Default white
            
            // Try to get color from the stage material
            stageObject.traverse((child) => {
                if (child.isMesh && child.material) {
                    const material = child.material;
                    
                    // If material has a map (texture), sample its average color
                    if (material.map && material.map.image) {
                        // Create a canvas to sample the texture
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 32;
                        canvas.height = 32;
                        
                        // Draw the texture to canvas
                        ctx.drawImage(material.map.image, 0, 0, 32, 32);
                        
                        // Sample pixels to get average color
                        const imageData = ctx.getImageData(0, 0, 32, 32);
                        const data = imageData.data;
                        let r = 0, g = 0, b = 0;
                        const pixelCount = data.length / 4;
                        
                        for (let i = 0; i < data.length; i += 4) {
                            r += data[i];
                            g += data[i + 1];
                            b += data[i + 2];
                        }
                        
                        // Calculate average and convert to hex
                        r = Math.floor(r / pixelCount);
                        g = Math.floor(g / pixelCount);
                        b = Math.floor(b / pixelCount);
                        
                        lightColor = (r << 16) | (g << 8) | b;
                        console.log(`Extracted stage texture color: RGB(${r}, ${g}, ${b}) = 0x${lightColor.toString(16)}`);
                    }
                    // Fallback to material color if no texture
                    else if (material.color) {
                        lightColor = material.color.getHex();
                        console.log(`Using stage material color: 0x${lightColor.toString(16)}`);
                    }
                }
            });
            
            // Create a RectAreaLight that matches the stage dimensions with extracted color
            const stageRectLight = new THREE.RectAreaLight(
                lightColor,  // Use extracted color
                2000,         // Intensity
                size.x,    // Width
                size.z     // Height
            );
            
            // Position the light at the stage center, slightly above
            stageRectLight.position.copy(center);
            stageRectLight.position.y = center.y + 0.1; // Slightly above the stage
            stageRectLight.position.z = center.z + 15; // Move slightly forward
            
            // Rotate to face in positive Z direction (forward)
            stageRectLight.rotation.x = 0; // No X rotation
            stageRectLight.rotation.y = Math.PI / 1; // No Y rotation
            stageRectLight.rotation.z = 0; // No Z rotation
            
            // Add to scene
            scene.add(stageRectLight);
            stageLight = stageRectLight;
            
            console.log("Stage RectAreaLight created at position:", center);
            console.log("Stage light dimensions:", size.x, "x", size.z);
            console.log("Stage light color:", `0x${lightColor.toString(16)}`);
            
            // Also create multiple point lights for better coverage using the same color
            const numPointLights = 6;
            const lightIntensity = 3;
            const lightDistance = 5;
            
            for (let i = 0; i < numPointLights; i++) {
                const angle = (i / numPointLights) * Math.PI * 2;
                const radius = Math.max(size.x, size.z) * 0.3;
                
                const pointLight = new THREE.PointLight(lightColor, lightIntensity, lightDistance);
                pointLight.position.set(
                    center.x + Math.cos(angle) * radius,
                    center.y + 1,
                    center.z + Math.sin(angle) * radius
                );
                
                scene.add(pointLight);
                console.log(`Stage point light ${i + 1} created at:`, pointLight.position);
            }
        }
        
        // Performance monitoring functions
    </script>
</body>
</html> 